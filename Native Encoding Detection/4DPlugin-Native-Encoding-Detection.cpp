/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Native-Encoding-Detection.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Native Encoding Detection
 #	author : miyako
 #	2021/04/24
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Native-Encoding-Detection.h"

#pragma mark -

#if VERSIONWIN
static INT count_windows_encodings = 0L;
#else
static ItemCount count_windows_encodings = 0L;
#endif

static void InitPlugin() {
    
#if VERSIONWIN
    IMultiLanguage2* mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void**)&mlang);
    //not support on windows xp; who cares...
    if(mlang)
    {
        ULONG count, celt = 32;//    number of codes page information to retrive at a time
        unsigned int index = 1;
        MIMECPINFO infos[32];
        IEnumCodePage* codepages = NULL;
        mlang->EnumCodePages(MIMECONTF_VALID, 0, &codepages);
        if(codepages)
        {
            while(codepages->Next(celt, infos, &count) == S_OK)
            {
                count_windows_encodings+=count;
            }
            codepages->Release();
        }
        mlang->Release();
    }
#else
    ItemCount count = 0L;
    if(!TECCountAvailableTextEncodings(&count))
    {
        count_windows_encodings = count;
    }
#endif
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                InitPlugin();
                break;
			// --- Native Encoding Detection
            
			case 1 :
				NED_Detect_encoding(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static void collection_push(PA_CollectionRef c, PA_ObjectRef value) {
    
    if(value) {
        PA_Variable v = PA_CreateVariable(eVK_Object);
        PA_SetObjectVariable(&v, value);
        PA_SetCollectionElement(c, PA_GetCollectionLength(c), v);
        PA_ClearVariable(&v);
    }
}

void NED_Detect_encoding(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    PA_CollectionRef results = PA_CreateCollection();
    
    PA_long32 len = PA_GetBlobParameter(params, 1, NULL);
    
    if(len)
    {
        std::vector<uint8_t>buf(len);
        void *bytes = &buf[0];
        PA_GetBlobParameter(params, 1, bytes);

        PA_ObjectRef options = PA_GetObjectParameter(params, 2);
#if VERSIONWIN
        DWORD dwFlag = 0L;
        DWORD dwPrefWinCodePage = 0L;
#endif
        if(options) {
#if VERSIONWIN
            if(ob_is_defined(options, L"sourceTextType")) {
                CUTF8String _u8;
                if(ob_get_s(options, L"sourceTextType", &_u8)) {
                    if(_u8 == (const uint8_t *)"7bit") {
                        dwFlag = MLDETECTCP_7BIT;
                    }
                    if(_u8 == (const uint8_t *)"8bit") {
                        dwFlag = MLDETECTCP_8BIT;
                    }
                    if(_u8 == (const uint8_t *)"dbcs") {
                        dwFlag = MLDETECTCP_DBCS;
                    }
                    if(_u8 == (const uint8_t *)"html") {
                        dwFlag = MLDETECTCP_HTML;
                    }
                }
            }
            if(ob_is_defined(options, L"preferredCodePage")) {
                dwPrefWinCodePage = ob_get_n(options, L"preferredCodePage");
            }
#endif


        }
        
        
        
#if VERSIONWIN
    
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {
        int scores = count_windows_encodings;
        std::vector<DetectEncodingInfo> encodings(scores);
		INT size = len;
        mlang->DetectInputCodepage(MLDETECTCP_NONE, 0, (CHAR *)bytes, (INT *)&size, &encodings[0], &scores);
        
        //no HRESULT?
        for(int i = 0; i < scores ; ++i)
        {
            if(encodings[i].nLangID != 0)
            {
                DetectEncodingInfo encoding = encodings[i];
                
                MIMECPINFO codePageInfo;
                if(S_OK == mlang->GetCodePageInfo(encoding.nCodePage, encoding.nLangID, &codePageInfo)) {
                    
                    PA_ObjectRef o = PA_CreateObject();
                    //DetectEncodingInfo
					UINT language = encoding.nLangID;
					if (language == (UINT)-1) {
						ob_set_n(o, L"language", -1);
					}
					else
					{
						ob_set_n(o, L"language", language);
					}
                    ob_set_n(o, L"code", encoding.nCodePage);
                    ob_set_n(o, L"percentage", encoding.nDocPercent);
                    ob_set_n(o, L"confidence", encoding.nConfidence);
                    //MIMECPINFO
//                    ob_set_n(o, L"familyCodePage", codePageInfo.uiFamilyCodePage);
                    ob_set_a(o, L"name", codePageInfo.wszDescription);
                    ob_set_a(o, L"charset", codePageInfo.wszWebCharset);
//                    ob_set_a(o, L"headerCharset", codePageInfo.wszHeaderCharset);
//                    ob_set_a(o, L"bodyCharset", codePageInfo.wszBodyCharset);
                    ob_set_a(o, L"fixedWidthFont", codePageInfo.wszFixedWidthFont);
                    ob_set_a(o, L"proportionalFont", codePageInfo.wszProportionalFont);
                    
                    collection_push(results, o);
                }
            }
        }

        mlang->Release();
    }
#else
        ItemCount count = count_windows_encodings;
        ItemCount num;

        std::vector<TextEncoding> _encodings(count);
        TextEncoding *encodings = &_encodings[0];
        
        TECGetAvailableTextEncodings(encodings, count, &num);
        TECSnifferObjectRef sniffer;
        
        if(!TECCreateSniffer(&sniffer, encodings, num)) {
            ItemCount numTextEncodings = num;
            ItemCount maxErrs = len;
            ItemCount maxFeatures = len;
            std::vector<ItemCount> _numErrsArray(count);
            ItemCount *numErrsArray = &_numErrsArray[0];
            std::vector<ItemCount> _numFeaturesArray(count);
            ItemCount *numFeaturesArray = &_numFeaturesArray[0];
            OSStatus status = TECSniffTextEncoding(sniffer,
                                                   (ConstTextPtr)bytes,
                                                   (ByteCount)len,
                                                   encodings,
                                                   numTextEncodings,
                                                   numErrsArray,
                                                   maxErrs,
                                                   numFeaturesArray,
                                                   maxFeatures);
            if(!status){
                ByteCount length = 0L;
                TextEncoding unicode = CreateTextEncoding(kTextEncodingUnicodeDefault,
                                                          kTextEncodingDefaultVariant,
                                                          kUnicodeUTF8Format);
                for(unsigned int i = 0; i < numTextEncodings; ++i)
                {
                    if(numErrsArray[i]){
                        break;
                    }else{
                        
                        TextEncoding encoding = encodings[i];

                        PA_ObjectRef o = PA_CreateObject();
                        
                        /*
                         std::vector<char> _buf(MAX_LENGTH_FOR_ENCODING_NAME);
                         if(!GetTextEncodingName(
                                                 encoding,
                                                 kTextEncodingFullName,
                                                 0,
                                                 unicode,
                                                 MAX_LENGTH_FOR_ENCODING_NAME,
                                                 &length,
                                                 NULL,
                                                 NULL,
                                                 (TextPtr)&_buf[0]))
                         {
                             CUTF8String u8 = CUTF8String((const uint8_t *)&_buf[0], length);
                             ob_set_s(o, L"name", (const char *)u8.c_str());
                         }
                         */

                        NSString *name = (NSString *)CFStringGetNameOfEncoding((CFStringEncoding)encoding);
                        ob_set_s(o, L"name", (const char *)[name UTF8String]);
                        
                        ScriptCode TextScriptID;
                        LangCode TextLanguageID;/* can be NULL */
                        if(!GetScriptInfoFromTextEncoding(
                                                           encoding,
                                                           &TextScriptID,
                                                           &TextLanguageID))
                        {
                            ob_set_n(o, L"script", TextScriptID);
                            ob_set_n(o, L"language", TextLanguageID);
                        }
                        
                        /*
                         ob_set_n(o, L"base", GetTextEncodingBase(encoding));
                         ob_set_n(o, L"variant", GetTextEncodingVariant(encoding) );
                         ob_set_n(o, L"format", GetTextEncodingFormat(encoding));

                         */

                        NSString *charset = (NSString *)CFStringConvertEncodingToIANACharSetName((CFStringEncoding)encoding);
                        ob_set_s(o, L"charset", (const char *)[charset UTF8String]);
                        
                        UInt32 codePage = CFStringConvertEncodingToWindowsCodepage(encoding);
                        if(codePage == kCFStringEncodingInvalidId){
                            ob_set_n(o, L"code", -1);
                        }else{
                            ob_set_n(o, L"code", codePage);
                        }
                        collection_push(results, o);
                    }
                    
                }
                
            }
            TECDisposeSniffer(sniffer);
        }
#endif
    }
    
    ob_set_c(returnValue, L"encodings", results);
    PA_ReturnObject(params, returnValue);
    
}

